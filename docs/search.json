[
  {
    "objectID": "index.html#preface",
    "href": "index.html#preface",
    "title": "Practice R: The Tutorials",
    "section": "Preface",
    "text": "Preface\nThis website gives access to all tutorials of Practice R (Treischl 2023). Practice R is a text book for the social sciences which provides several tutorials supporting students to learn R. Feel free to inspect the tutorials even if you are not familiar with the book, but keep in mind the tutorials are supposed to complement the Practice R book."
  },
  {
    "objectID": "index.html#the-book",
    "href": "index.html#the-book",
    "title": "Practice R: The Tutorials",
    "section": "The book",
    "text": "The book\nMany students learn to analyze data using commercial packages, even though there is an open-source software with cutting-edge possibilities: R, a programming language with countless cool features for applied empirical research.\nPractice R introduces R to social science students, inspiring them to consider R as an excellent choice. In a non-technical pragmatic way, this book covers all typical steps of applied empirical research.\nLearn how to prepare, analyze, and visualize data in R. Discover how to collect data, generate reports, or automate error-prone tasks.\nThe book is accompanied by an R package. This provides further learning materials that include interactive tutorials, challenging you with typical problems of applied research. This way, you can immediately practice the knowledge you have learned. The package also includes the source code of each chapter and templates that help to create reports.\nPractice R has social science students in mind, nonetheless a broader audience may use Practice R to become a proficient R user.\n\nIntroduces R in a non-technical fashion\nCovers typical steps of applied empirical research\nComplemented by interactive tutorials\nWith access to all materials via the Practice R Package\n\n\n\n\n\nTreischl, Edgar J. 2023. Practice R: An Interactive Textbook. De Gruyter Oldenbourg."
  },
  {
    "objectID": "chapter_02.html#typical-error-messages",
    "href": "chapter_02.html#typical-error-messages",
    "title": "1  Base R",
    "section": "1.1 Typical error messages",
    "text": "1.1 Typical error messages\nWhat kind of errors do we need to talk about? Sometimes we introduce errors when we are not cautious enough about the code. Spelling mistakes (e.g., typos, missing and wrong characters, etc.) are easy to fix yet hard to find. For example, I tried to use the assignment operator, but something went wrong. Do you know what might be the problem?\n\n#Assigning the values the wrong way\na -&lt; 5\nb -&lt; 3\n\na + b\n\n#&gt; Error: &lt;text&gt;:2:4: unexpected '&lt;'\n#&gt; 1: #Assigning the values the wrong way\n#&gt; 2: a -&lt;\n#&gt;       ^\n\n\n\n# Keep the short cut for the assignment operator in mind:\n#&lt;Alt/Option&gt; + &lt;-&gt;\n\n# Solution:\na &lt;- 5\nb &lt;- 3\n\na + b\n\n#&gt; [1] 8\n\n\nFinding spelling mistakes in your own code can be hard. There are certainly several reasons, but our human nature to complete text certainly is part of it. This ability gives us the possibility to read fast, but it makes it difficult to see our own mistakes. Don’t get frustrated, it happens even if you have a lot of experience working with R. Thus, check if there are no simple orthographically mistakes - such as typos, missing (extra) parentheses, and commas - which prevents the code from running.\nI highlighted in Chapter 2 that RStudio inserts opening and closing parentheses, which reduces the chance that missing (or wrong) characters create an error, but there is no guarantee that we insert or delete one by chance. Suppose you try to estimate a mean in combination with the round() function. I put a parenthesis at a wrong place, which is why R throws an error. Can you see which parenthesis is causing the problem?\n\n#Check parenthesis\nround(mean(c(1, 4, 6))), digits = 2)\n\n#&gt; Error: &lt;text&gt;:2:24: unexpected ','\n#&gt; 1: #Check parenthesis\n#&gt; 2: round(mean(c(1, 4, 6))),\n#&gt;                           ^\n\n\n\n# Solution:\nround(mean(c(1, 4, 6)), digits = 2)\n\n#&gt; [1] 3.67\n\n\nThis error is hard to spot, but it illustrates that we need to be careful not to introduce mistakes. Moreover, RStudio gives parentheses that belong together the same color which help us to keep overview. Go to the RStudio menu (via the &lt;Code&gt; tab) and select rainbow parentheses if they are not displayed in color in the Code pane.\nUnfortunately, RStudio cannot help us all the time because some R errors messages (and warnings) are cryptic. There are even typical errors messages that are quite obscure for beginners. For example, R tells me all the time that it can’t find an object, functions, and data. There are several explanations why R throws such an error. If R cannot find an object, check if the object is listed in the environment. If so, you know for sure that the object exists and that other reasons cause the error. R cannot find an object even in the case of a simple typo.\n\n# R cannot find an object due to typos\nmean_a &lt;- mean(1, 2, 3)\nmaen_a\n\n#&gt; Error in eval(expr, envir, enclos): object 'maen_a' not found\n\n\n\n# Solution:\nmean_a &lt;- mean(1, 2, 3)\nmean_a\n\n#&gt; [1] 1\n\n\nR tells us that a function (an object) cannot be found if different notations are used. Keep in mind that R is case-sensitive (r vs. R) and cannot apply a function (or find an object) that does not exist, as the next console illustrates. Of course, the same applies if you forgot to execute the function before using it or if the function itself includes an error and cannot be executed. In all these examples R cannot find the function (or object).\n\n# R is case-sensitive\nreturn_fun &lt;- function(x) {\n  return(x)\n}\n\nReturn_fun(c(1, 2, 3))\n\n#&gt; Error in Return_fun(c(1, 2, 3)): could not find function \"Return_fun\"\n\n\n\n# Solution:\nreturn_fun(c(1, 2, 3))\n\n#&gt; [1] 1 2 3\n\n\nWhat is the typical reason why a function from an R package cannot be found? I started to introduce the dplyr package in Chapter 2 (Wickham et al. 2022). Suppose we want to use the select function from the package. To use anything from an R package, we need to load the package with the library() function each time we start (over). Otherwise, R cannot find the function.\n\n# Load the package to use a function from a package\nlibrary(palmerpenguins)\nselect(penguins, species)\n\n#&gt; Error in select(penguins, species): could not find function \"select\"\n\n\n\n# Solution:\ndplyr::select(penguins, species)\n\n#&gt; # A tibble: 344 × 1\n#&gt;    species\n#&gt;    &lt;fct&gt;  \n#&gt;  1 Adelie \n#&gt;  2 Adelie \n#&gt;  3 Adelie \n#&gt;  4 Adelie \n#&gt;  5 Adelie \n#&gt;  6 Adelie \n#&gt;  7 Adelie \n#&gt;  8 Adelie \n#&gt;  9 Adelie \n#&gt; 10 Adelie \n#&gt; # ℹ 334 more rows\n\n\nThe same applies to objects from a package (e.g., data). The .packages() function returns all loaded (attached) packages, but there is no need to keep that in mind. Go to the packages pane and check if a package is installed and loaded. R tells us only that the function cannot be found if we forget to load it first.\n\n# Inspect the loaded packages via the Packages pane\nloaded_packages &lt;- .packages()\nloaded_packages\n\n#&gt; [1] \"palmerpenguins\" \"stats\"          \"graphics\"       \"grDevices\"     \n#&gt; [5] \"utils\"          \"datasets\"       \"methods\"        \"base\"\n\n\nUltimately, suppose we try to import data. Never mind about the code, we focus on this step in Chapter 5 in detail, but R tells us that it cannot open the connection if the file cannot be found in the current working directory.\n\n# Load my mydata\nread.csv(\"mydata.csv\")\n\n#&gt; Warning in file(file, \"rt\"): cannot open file 'mydata.csv': No such file or\n#&gt; directory\n\n\n#&gt; Error in file(file, \"rt\"): cannot open the connection\n\n\nR tells that data, or other files cannot be found because we provided the wrong path to the file. We will learn how to import data later, but keep in mind that R cannot open a file if we search in the wrong place. In Chapter 2, I outlined many possibilities to change the work directory for which RStudio supplies convenient ways. In addition, the getwd() function returns the current work directory in case of any doubts.\n\n# Do we search for files in the right place\ngetwd()\n#&gt; [1] \"C:/Users/Edgar/R/Practice_R/Tutorial/02\"\n\nLoading the right packages and searching in the right place does not imply that we cannot inadvertently introduce mistakes. Suppose you want to apply the filter function from the dplyr package. You copy and adjust the code from an old script, but R returns an error. Can you see where I made the mistake? I tried to create a subset with Adelie penguins only, but dplyr seems to know what the problem might be.\n\n# Mistakes happen all the time ...\nlibrary(dplyr)\nfilter(penguins, species = \"Adelie\")\n\n#&gt; Error in `filter()`:\n#&gt; ! We detected a named input.\n#&gt; ℹ This usually means that you've used `=` instead of `==`.\n#&gt; ℹ Did you mean `species == \"Adelie\"`?\n\n\n\n# Solution:\nlibrary(dplyr)\nfilter(penguins, species == \"Adelie\")\n\n#&gt; # A tibble: 152 × 8\n#&gt;    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n#&gt;    &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n#&gt;  1 Adelie  Torgersen           39.1          18.7               181        3750\n#&gt;  2 Adelie  Torgersen           39.5          17.4               186        3800\n#&gt;  3 Adelie  Torgersen           40.3          18                 195        3250\n#&gt;  4 Adelie  Torgersen           NA            NA                  NA          NA\n#&gt;  5 Adelie  Torgersen           36.7          19.3               193        3450\n#&gt;  6 Adelie  Torgersen           39.3          20.6               190        3650\n#&gt;  7 Adelie  Torgersen           38.9          17.8               181        3625\n#&gt;  8 Adelie  Torgersen           39.2          19.6               195        4675\n#&gt;  9 Adelie  Torgersen           34.1          18.1               193        3475\n#&gt; 10 Adelie  Torgersen           42            20.2               190        4250\n#&gt; # ℹ 142 more rows\n#&gt; # ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\nTypos, missing functions (objects), and confusion about operators are typical mistakes and some packages return suggestions to fix the problem. Unfortunately, R can also return cryptic error messages, which are often harder to understand."
  },
  {
    "objectID": "chapter_02.html#cryptic-errors",
    "href": "chapter_02.html#cryptic-errors",
    "title": "1  Base R",
    "section": "1.2 Cryptic errors",
    "text": "1.2 Cryptic errors\nNot all error R messages and warnings are cryptic. Suppose you wanted to estimate a mean of an income variable. The variable is not measured numerically which implies that the mean cannot be estimated. Consequently, R warns us about wrong and inconsistent data types.\n\n# Warning: argument is not numeric or logical\nincome &lt;- c(\"More than 10000\", \"0 - 999\", \"2000 - 2999\")\nmean(income)\n\n#&gt; Warning in mean.default(income): argument is not numeric or logical: returning\n#&gt; NA\n\n\nUnfortunately, some errors and warnings seem more like an enigma than useful feedback. Imagine, R tells you that a non-numeric argument has been applied to a binary operator. The next console reproduces the error with two example vectors. The last value of the vector y is a character (e.g., a missing value indicator: NA) and for obvious reasons we cannot multiply x with y as long as we do clean the latter.\n\n# Cryptic error: A non-numeric argument to binary operator\nx &lt;- c(3, 5, 3)\ny &lt;- c(1, 4, \"NA\")\n\nresult &lt;- x * y\n\n#&gt; Error in x * y: non-numeric argument to binary operator\n\nresult\n\n#&gt; Error in eval(expr, envir, enclos): object 'result' not found\n\n\nWe will learn how to fix such problem in a systematic manner later, for now just keep in mind that such an error message might be due to messy, not yet prepared data. Or suppose you tried to estimate the sum but R tells you that the code includes an unexpected numeric constant. Any idea what that means and how to fix the example code of the next console?\n\n#Cryptic error: Unexpected numeric constant\nsum(c(3, 2 1))\n\n#&gt; Error: &lt;text&gt;:2:12: unexpected numeric constant\n#&gt; 1: #Cryptic error: Unexpected numeric constant\n#&gt; 2: sum(c(3, 2 1\n#&gt;               ^\n\n\n\n# Solution:\nsum(c(3, 2, 1))\n\n#&gt; [1] 6\n\n\nR finds an unexpected numeric constant (here 1) because I forgot the last comma inside the c() function. The same applies to strings and characters. R tells us that there is an unexpected string constant. Can you see where?\n\n#Cryptic error: Unexpected string constant\nnames &lt;- c(\"Tom\", \"Diana\"___\"Pete\")\nnames\n\n#&gt; Error: &lt;text&gt;:2:26: unexpected input\n#&gt; 1: #Cryptic error: Unexpected string constant\n#&gt; 2: names &lt;- c(\"Tom\", \"Diana\"_\n#&gt;                             ^\n\n\n\n# Solution:\nnames &lt;- c(\"Tom\", \"Diana\", \"Pete\")\nnames\n\n#&gt; [1] \"Tom\"   \"Diana\" \"Pete\"\n\n\nOr consider unexpected symbols. Can you find the problem of the next console. I used to round function but something went wrong with the digits option.\n\n#Cryptic error: Unexpected symbol\nx &lt;- mean(c(1:3))\nround(x digits = 2)\n\n#&gt; Error: &lt;text&gt;:3:9: unexpected symbol\n#&gt; 2: x &lt;- mean(c(1:3))\n#&gt; 3: round(x digits\n#&gt;            ^\n\n\n\n# Solution:\nx &lt;- mean(c(1:3))\nround(x, digits = 2)\n\n#&gt; [1] 2\n\n\nThus, we introduce a mistake with a function argument because the comma is missing. A similar mistake happens if we forget to provide a necessary argument or provide a wrong one. For example, there is no numbers option of the round function as the next console (and the help files ?round) outline.\n\n# Cryptic error: Unused argument\nx &lt;- mean(c(1:3))\nround(x, numbers = 2)\n\n#&gt; Error in round(x, numbers = 2): unused argument (numbers = 2)\n\n\n\n# Solution:\nx &lt;- mean(c(1:3))\nround(x, digits = 2)\n\n#&gt; [1] 2\n\n\nTry to be patient and be kind to yourself should you run into such an error. You will become better to solve errors, but they will happen all the time. Let me give you one more for the road. Consider the error message: object of type ‘closure’ is not subsettable. R returns this error message if we try to slice a variable that does not exist or if we try to slice a function instead of providing a column vector. Can you fix the next console and provide a column vectors instead of slicing the mean() function?\n\n# Cryptic error: Object of type 'closure' is not subsettable\nmean[1:5]\n\n#&gt; Error in mean[1:5]: object of type 'closure' is not subsettable\n\n\n\n# Solution:\nmean(1:5)\n\n#&gt; [1] 3"
  },
  {
    "objectID": "chapter_02.html#further-sources-of-errors",
    "href": "chapter_02.html#further-sources-of-errors",
    "title": "1  Base R",
    "section": "1.3 Further sources of errors",
    "text": "1.3 Further sources of errors\nThere are further errors and mistakes and this tutorial cannot capture them all. As a minimum, I try to give you a heads-up that it takes time and experience to overcome such problems. For example, consider one more time the small data that we used to slice data in Practice R.\n\n# Save data as df\ndf &lt;- tibble::tribble(\n  ~names, ~year, ~sex,\n  \"Bruno\", 1985, \"male\",\n  \"Justin\", 1994, \"male\",\n  \"Miley\", 1992, \"female\",\n  \"Ariana\", 1993, \"female\"\n)\n\nDo you still remember how to slice the data? Give it a try with the following examples:\n\n# Slice the first column (variable)\ndf[1]\n\n#&gt; # A tibble: 4 × 1\n#&gt;   names \n#&gt;   &lt;chr&gt; \n#&gt; 1 Bruno \n#&gt; 2 Justin\n#&gt; 3 Miley \n#&gt; 4 Ariana\n\n\n\n# First row\ndf[1, ]\n\n#&gt; # A tibble: 1 × 3\n#&gt;   names  year sex  \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Bruno  1985 male\n\n\nSuppose that you have not worked with R for a few weeks, would you still be able to remember how slicing works? We all face the same problems when we start to learn something new: you need several attempts before you understand how to get the desired information. Later, after slicing data many times, you will no longer think about how it works. Thus, be patient and kind to yourself, because some concepts need time and experience to internalize them.\nMoreover, there are often several approaches to reach the same goal and - depending on your preferred style - some are harder or easier to apply. Say you need the names of the stars as a column vector. Can you slice the data or use the $ operator to get the names variable from the data frame?\n\n# Slice or use the $ operator\nnames &lt;- df$names\nnames &lt;- df[1]\nnames\n\n#&gt; # A tibble: 4 × 1\n#&gt;   names \n#&gt;   &lt;chr&gt; \n#&gt; 1 Bruno \n#&gt; 2 Justin\n#&gt; 3 Miley \n#&gt; 4 Ariana\n\n\nUnfortunately, some mistakes are logical in nature and pure practice cannot help us to overcome such problems. Consider the next console. I created a slice function (slice_function) which is supposed to return an element of a vector x, but so far it only returns non-sense. Why does it not return the second element of the input data?\n\n# A pretty messed up slice_function\ndata &lt;- c(3, 9, 1, 5, 8, \"999\", 1)\n\nslice_function &lt;- function(data, x) {\n  data[x]\n}\n\nslice_function(2)\n\n#&gt; [1] 2\n\n\n\n# Solution:\ndata &lt;- c(3, 9, 1, 5, 8, 1)\n\nslice_function &lt;- function(data, x) {\n  data[x]\n}\n\nslice_function(data, x = 2)\n\n#&gt; [1] 9\n\n\nSoon, your code will encompass several steps, try to break it into its separate elements and then examine each step carefully. For example, inspect the vector x to see if error was introduced in the first step. Use the class() function to examine if the input of a variable is as expected (e.g. numerical). If we are sure about the input, we would go on to the next step and so on. Certainly, the last example is not complicated but the complexity of code (and the tasks) will increase from the chapter to chapter. By breaking down all steps into elements, you may realize where the error occurs and how you can fix it."
  },
  {
    "objectID": "chapter_02.html#summary",
    "href": "chapter_02.html#summary",
    "title": "1  Base R",
    "section": "1.4 Summary",
    "text": "1.4 Summary\nAll tutorials of Practice R will end with a short code summary of the corresponding book chapter. The summary only contains the function name from the R help file and code example of the most important functions and packages. In connection with Chapter 2, keep the following functions in mind:\n\nInstall packages from repositories or local files (install.packages)\nLoading/attaching and listing of packages(library)\nInspect the help file (?function)\nCombine Values into a vector or list (c)\nCompare objects (&lt;=, &gt;=, ==, !=)\nReplicate elements of vectors and lists (rep)\nSequence generation (seq)\nSum of vector elements (sum)\nLength of an object (length)\nObject classes (class)\nData frames (data.frame)\nBuild a data frame (tibble::tibble, Müller and Wickham 2022)\nRow-wise tibble creation (tibble::tribble)\nThe number of rows/columns of an array (nrow/ncol)\n\nBase R and many R packages have cheat sheets that summarize the most important features. You can inspect them directly from RStudio (via the &lt;help&gt; tab) and I included the link to the base R cheat sheet in the PracticeR package.\n\n# Cheat sheets summarize the most important features\n# The base R cheat sheet\nPracticeR::show_link(\"base_r\")\n\n\n\n\n\nMüller, Kirill, and Hadley Wickham. 2022. tibble: Simple Data Frames. https://CRAN.R-project.org/package=tibble.\n\n\nTreischl, Edgar J. 2023. Practice R: An Interactive Textbook. De Gruyter Oldenbourg.\n\n\nWickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2022. dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr."
  },
  {
    "objectID": "chapter_03.html#categorical-variables",
    "href": "chapter_03.html#categorical-variables",
    "title": "2  Data Exploration",
    "section": "2.1 Categorical variables",
    "text": "2.1 Categorical variables\nWe started to explore categorical variables in Chapter 3 and I outlined a few basics about factor variables. Suppose we want to explore the factor variable island, which indicates where the penguins live. How can you examine unique group levels?\n\n# Inspect the levels() of the penguin's home island\nlevels(df$island)\n\n#&gt; [1] \"Biscoe\"    \"Dream\"     \"Torgersen\"\n\n\nWe will deepen our knowledge about factor variables in Chapter 5, but keep in mind that we can (re-) create and adjust factor() variables. For example, suppose the data looks like a messy character vector for penguin’s sex that I have created in the next console. In such a case it is good to remember that we can give the variable proper text labels (e.g., female for f) and examine the results.\n\n# Example of a messy factor variable\nsex &lt;- c(\"m\", \"f\", \"f\")\n\n# Give clearer labels\nsex &lt;- factor(sex,\n  levels = c(\"f\", \"m\"),\n  labels = c(\"female\", \"male\"),\n)\nhead(sex)\n\n#&gt; [1] male   female female\n#&gt; Levels: female male\n\n\nTables help us to explore data and we used the summarytools package to make frequency and cross tables (Comtois 2022). Keep in mind that we will learn how to create text documents with tables and graphs in Chapter 8. For the moment it is enough to remember that we can create different sort of tables with the summarytools package. For example, create a frequency (freq) table to find out on which island most of the penguins live.\n\n# Create a frequency table\nfreq(df$island)\n\n#&gt; Frequencies  \n#&gt; df$island  \n#&gt; Type: Factor  \n#&gt; \n#&gt;                   Freq   % Valid   % Valid Cum.   % Total   % Total Cum.\n#&gt; --------------- ------ --------- -------------- --------- --------------\n#&gt;          Biscoe    168     48.84          48.84     48.84          48.84\n#&gt;           Dream    124     36.05          84.88     36.05          84.88\n#&gt;       Torgersen     52     15.12         100.00     15.12         100.00\n#&gt;            &lt;NA&gt;      0                               0.00         100.00\n#&gt;           Total    344    100.00         100.00    100.00         100.00\n\n\nAs outlined in the book, we can use the table() function to count categorical variables and plot the result as a bar graph. I introduced the latter approach because it is very easy to apply, but our code becomes clearer if we make the necessary steps visible. First, we need to count the levels before we can plot the results. The count() function from the dplyr package does this job (Wickham et al. 2022). It needs only the data frame and the factor variable.\n\n# Count islands with dplyr\ncount_island &lt;- dplyr::count(df, island)\ncount_island\n\n#&gt; # A tibble: 3 × 2\n#&gt;   island        n\n#&gt;   &lt;fct&gt;     &lt;int&gt;\n#&gt; 1 Biscoe      168\n#&gt; 2 Dream       124\n#&gt; 3 Torgersen    52\n\n\nNext, use the assigned results (count_island) and insert the variables into the barplot() function (with the formula y ~ x).\n\n# Create a barplot\nbarplot(n ~ island, data = count_island)\n\n\n\n\n\nIn a similar vein, I introduced functions from the DataExplorer package that help us to get a quick overview (Cui 2020). For example, use the plot_bar() function to depict several or all discrete variables of a data frame.\n\n# Inspect all or several plots at once\nDataExplorer::plot_bar(df[1:2])"
  },
  {
    "objectID": "chapter_03.html#continuous-variables",
    "href": "chapter_03.html#continuous-variables",
    "title": "2  Data Exploration",
    "section": "2.2 Continuous variables",
    "text": "2.2 Continuous variables\nTo explore continuous variables, estimate the summary statistics with the summary() function. Pick one variable such as penguin’s body mass in gram (body_mass_g) or use the entire data frame.\n\n# Get a summary\nsummary(df[1:4])\n\n#&gt;       species          island    bill_length_mm  bill_depth_mm  \n#&gt;  Adelie   :152   Biscoe   :168   Min.   :32.10   Min.   :13.10  \n#&gt;  Chinstrap: 68   Dream    :124   1st Qu.:39.23   1st Qu.:15.60  \n#&gt;  Gentoo   :124   Torgersen: 52   Median :44.45   Median :17.30  \n#&gt;                                  Mean   :43.92   Mean   :17.15  \n#&gt;                                  3rd Qu.:48.50   3rd Qu.:18.70  \n#&gt;                                  Max.   :59.60   Max.   :21.50  \n#&gt;                                  NA's   :2       NA's   :2\n\n\nThe classic approach to visualize the distribution of a continuous variable is a histogram. Use the hist() function to display the distribution of the penguins body mass.\n\n# Create a histogram\nhist(df$body_mass_g)\n\n\n\n\nKeep in mind that we only explored the data for the first time. We did not clean the data nor did we prepare the variables. We have to be explicit about missing values when we want to apply functions such as the mean. The function returns NA, but only because of a missing values problem. Can you remember how to fix this problem and estimate, for example, the mean?\n\n# Calculate the mean, but what about missing values (na.rm)?\nmean(df$body_mass_g, na.rm = TRUE)\n\n#&gt; [1] 4201.754\n\n\nI picked data that was more or less prepared to be explored, because data preparation needs more time and effort especially in the beginning. For this reason we will learn how to manipulate data in Chapter 4; and Chapter 5 tries to prepare you for own journey. For example, we use packages such as visdat and naniar to identify missing values, as the next console illustrates with two examples (Tierney et al. 2021). The vis_dat() function from the corresponding packages shows us which type of data we have with missing values in gray; while vis_miss() visualizes missing values in general terms. Keep in mind that Chapter 3 did not introduce data preparation steps which are often necessary to explore data and effects between variables.\n\nlibrary(visdat)\n\n# Left plot: vis_dat()\nvis_dat(df)\n\n# Right plot: vis_miss()\nvis_miss(df)"
  },
  {
    "objectID": "chapter_03.html#explore-effects",
    "href": "chapter_03.html#explore-effects",
    "title": "2  Data Exploration",
    "section": "2.3 Explore effects",
    "text": "2.3 Explore effects\nLet’s start with an effect between two categorical variables. There are different packages that provides functions to create (cross) tables, but we used the summarytools package. It even provides a simulated data set which we will use the repeat the steps to create a cross table. The package comes with the tobacco data, which illustrates that smoking is harmful. As the next console shows, it indicates if a person is a smoker and if the person is diseased.\n\nhead(tobacco)[1:8]\n\n#&gt;   gender age age.gr      BMI smoker cigs.per.day diseased      disease\n#&gt; 1      M  75   71 + 29.50225     No            0       No         &lt;NA&gt;\n#&gt; 2      F  35  35-50 26.14989     No            0      Yes Neurological\n#&gt; 3      F  70  51-70 27.53183     No            0       No         &lt;NA&gt;\n#&gt; 4      F  40  35-50 24.05832     No            0       No         &lt;NA&gt;\n#&gt; 5      F  75   71 + 22.77486     No            0      Yes      Hearing\n#&gt; 6      M  38  35-50 21.46412     No            0       No         &lt;NA&gt;\n\n\nUse the ctable function from the summarytools package to make a cross table for these variables. See also what happens if you adjust the prop option. Insert c or t. Furthermore, explore what happens if you set the chisq, OR, or RR option to TRUE.\n\n# Create a cross table with summarytools\nsummarytools::ctable(\n  x = tobacco$smoker,\n  y = tobacco$diseased,\n  prop = \"r\",\n  chisq = TRUE,\n  OR = TRUE\n)\n\n#&gt; Cross-Tabulation, Row Proportions  \n#&gt; smoker * diseased  \n#&gt; Data Frame: tobacco  \n#&gt; \n#&gt; \n#&gt; -------- ---------- ------------- ------------- ---------------\n#&gt;            diseased           Yes            No           Total\n#&gt;   smoker                                                       \n#&gt;      Yes              125 (41.9%)   173 (58.1%)    298 (100.0%)\n#&gt;       No               99 (14.1%)   603 (85.9%)    702 (100.0%)\n#&gt;    Total              224 (22.4%)   776 (77.6%)   1000 (100.0%)\n#&gt; -------- ---------- ------------- ------------- ---------------\n#&gt; \n#&gt; ----------------------------\n#&gt;  Chi.squared   df   p.value \n#&gt; ------------- ---- ---------\n#&gt;    91.7088     1       0    \n#&gt; ----------------------------\n#&gt; \n#&gt; ----------------------------------\n#&gt;  Odds Ratio   Lo - 95%   Hi - 95% \n#&gt; ------------ ---------- ----------\n#&gt;     4.40        3.22       6.02   \n#&gt; ----------------------------------\n\n\nThe prop option lets you determine the proportions: rows (r), columns (c), total (t), or none (n). Furthermore, the function even adds the chi-square statistic (chisq); the odds ratio (OR) or the relative risk (RR) if we set them to TRUE. Never mind if you are not familiar with the latter, the discussed options only illustrated how the summarytools package helps us to explore data and effects.\nIn the social sciences we are often interested in comparing numerical outcomes between categorical variables (groups). For example, one of the penguin’s species has a higher body mass and we can examine which penguins species differ in terms of their body mass (body_mass_g). With base R, the aggregate() function lets us split the data and we are able to estimate the mean for each species.\n\n# Aggregate splits the data into subsets and computes summary statistics\naggregate(df$body_mass_g, list(df$species), FUN = mean, na.rm = TRUE)\n\n#&gt;     Group.1        x\n#&gt; 1    Adelie 3700.662\n#&gt; 2 Chinstrap 3733.088\n#&gt; 3    Gentoo 5076.016\n\n\nTo calculate a group-mean looks quite complicated and I did not introduce the latter since we will systematically work on our skills to manipulate data in the next Chapter. Instead, we used a box plot to explore a continuous outcome between groups. As outlined in the book, box plots can be very helpful to compare groups even though they have graphical limitations since they do not display the data. Keep the boxplot() function in mind and practice one more time how it works. Inspect how penguin’s body mass differs between the species.\n\n# Inspect group differences with a box plot\nboxplot(body_mass_g ~ species, data = df)\n\n\n\n\nIf we examine an effect between two continuous outcomes, we have to keep in mind that the plot function returns a scatter plot and we may insert a regression line with the abline and the lm function. Do you still know how it works? Create a scatter plot to examine the association between the body mass (body_mass_g) and the flipper length (flipper_length_mm) of the penguins.\n\n# Create a scatter plot\nplot(y = df$body_mass_g, x = df$flipper_length_mm)\n\n# And a red regression line\nabline(lm(body_mass_g ~ flipper_length_mm, data = df),\n  col = \"red\"\n)\n\n\n\n\nFurthermore, we learned how to calculate the correlation coefficient. The code of the next console does not work if I apply the cor() with the penguins data. Do you have any idea how to fix the problem?\n\n# Calculate the correlation between x and y\ncor_penguins &lt;- cor(df$body_mass_g, df$flipper_length_mm,\n  use = \"complete\"\n)\ncor_penguins\n\n#&gt; [1] 0.8712018\n\n\nBy the way, the cor() also returns Kendall’s or Spearman’s if you adjust the method option:\n\n# estimate a rank-based measure of association\ncor(x,\n  y = NULL, use = \"complete\",\n  method = c(\"pearson\", \"kendall\", \"spearman\")\n)\n\n\nFinally, the effectsize package helped us with the interpretation of Pearson’s r (and other stats, see Chapter 6). I copied the code from the book; can you adjust it to interpret the effect of the examined variables with the effectsize package (Ben-Shachar et al. 2022)?\n\n\n#&gt; [1] 0.8712018\n\n\n\n# Use effectsize to interpret R\neffectsize::interpret_r(cor_penguins, rules = \"cohen1988\")\n\n#&gt; [1] \"large\"\n#&gt; (Rules: cohen1988)\n\n\n\nThere are more R packages to explore data than I could possibly outline. For example, consider the skimr package (Waring et al. 2022). It skims a data set and returns, for example, a short summary, summary statistics, and missing values. Inspect the vignette and skim() the data frame.\n\n# Inspect skimr package (and vignette)\n# vignette(\"skimr\")\nskimr::skim(df)\n\nOr examine the ggpairs() function from the GGally package (Schloerke et al. 2021). It provides many extensions to create graphs (with ggplot2 see Chapter 7); and it also has functions to explore data and effects. The ggpairs() function returns a graph for a pairwise comparison of all variables. Depending on the data type, it returns bar plots, density plot, or the correlation between variables and combines all plots in one graph.\n\n# GGally: https://ggobi.github.io/ggally/\nGGally::ggpairs(df[2:5])"
  },
  {
    "objectID": "chapter_03.html#summary",
    "href": "chapter_03.html#summary",
    "title": "2  Data Exploration",
    "section": "2.4 Summary",
    "text": "2.4 Summary\nData exploration can be exciting since we explore something new. Unfortunately, it can be painful if the data is complex or messy. For this reason we used a simple and clean data, but we will start to manipulate complex(er) data and prepare messy data soon. Keep the following functions from Chapter 3 in mind:\n\nGet a glimpse of your data (dplyr::glimpse); display the structure of an object (str); and inspect the first or last parts of an object (head/tail)\nCreate a factor variable (factor); levels attributes (levels); object labels (labels)\nSimple cross table (table)\nGet a summary (summary)\nSummary statistics (min, mean, max, sd)\nCorrelation, variance and covariance (matrices) via (cor); or with the correlation package (Makowski et al. 2022)\nGraphs: Bar plots (barplot); histograms (hist), spine plot (spineplot), box plot (boxplot), scatter plot (plot), correlation matrix (corrplot::corrplot)\nPackages:\n\nThe summarytools package provides many tables: (e.g., freq, ctable)\nThe DataExplorer to visualize several variable at once: (e.g., plot_bar)\nThe effectsize package to interpret results: (e.g., interpret_r)"
  },
  {
    "objectID": "chapter_03.html#references",
    "href": "chapter_03.html#references",
    "title": "2  Data Exploration",
    "section": "2.5 References",
    "text": "2.5 References\n\n\n\n\nBen-Shachar, Mattan S., Dominique Makowski, Daniel Lüdecke, Indrajeet Patil, and Brenton M. Wiernik. 2022. effectsize: Indices of Effect Size. https://CRAN.R-project.org/package=effectsize.\n\n\nComtois, Dominic. 2022. summarytools: Tools to Quickly and Neatly Summarize Data. https://CRAN.R-project.org/package=summarytools.\n\n\nCui, Boxuan. 2020. DataExplorer: Automate Data Exploration and Treatment. https://CRAN.R-project.org/package=DataExplorer.\n\n\nHorst, Allison, Alison Hill, and Kristen Gorman. 2022. palmerpenguins: Palmer Archipelago (Antarctica) Penguin Data. https://CRAN.R-project.org/package=palmerpenguins.\n\n\nMakowski, Dominique, Brenton M. Wiernik, Indrajeet Patil, Daniel Lüdecke, and Mattan S. Ben-Shachar. 2022. Correlation: Methods for Correlation Analysis. https://CRAN.R-project.org/package=correlation.\n\n\nMüller, Kirill, and Hadley Wickham. 2022. pillar: Coloured Formatting for Columns. https://CRAN.R-project.org/package=pillar.\n\n\nSchloerke, Barret, Di Cook, Joseph Larmarange, Francois Briatte, Moritz Marbach, Edwin Thoen, Amos Elberg, and Jason Crowley. 2021. GGally: Extension to ggplot2. https://CRAN.R-project.org/package=GGally.\n\n\nTierney, Nicholas, Di Cook, Miles McBain, and Colin Fay. 2021. naniar: Data Structures, Summaries, and Visualisations for Missing Data. https://CRAN.R-project.org/package=naniar.\n\n\nTreischl, Edgar J. 2023. Practice R: An Interactive Textbook. De Gruyter Oldenbourg.\n\n\nWaring, Elin, Michael Quinn, Amelia McNamara, Eduardo Arino de la Rubia, Hao Zhu, and Shannon Ellis. 2022. skimr: Compact and Flexible Summaries of Data. https://CRAN.R-project.org/package=skimr.\n\n\nWickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2022. dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Ben-Shachar, Mattan S., Dominique Makowski, Daniel Lüdecke, Indrajeet\nPatil, and Brenton M. Wiernik. 2022. effectsize: Indices of Effect Size. https://CRAN.R-project.org/package=effectsize.\n\n\nComtois, Dominic. 2022. summarytools: Tools to\nQuickly and Neatly Summarize Data. https://CRAN.R-project.org/package=summarytools.\n\n\nCui, Boxuan. 2020. DataExplorer: Automate Data\nExploration and Treatment. https://CRAN.R-project.org/package=DataExplorer.\n\n\nHorst, Allison, Alison Hill, and Kristen Gorman. 2022. palmerpenguins: Palmer Archipelago (Antarctica) Penguin\nData. https://CRAN.R-project.org/package=palmerpenguins.\n\n\nMakowski, Dominique, Brenton M. Wiernik, Indrajeet Patil, Daniel\nLüdecke, and Mattan S. Ben-Shachar. 2022. Correlation:\nMethods for Correlation Analysis. https://CRAN.R-project.org/package=correlation.\n\n\nMüller, Kirill, and Hadley Wickham. 2022a. pillar: Coloured Formatting for Columns. https://CRAN.R-project.org/package=pillar.\n\n\n———. 2022b. tibble: Simple Data\nFrames. https://CRAN.R-project.org/package=tibble.\n\n\nSchloerke, Barret, Di Cook, Joseph Larmarange, Francois Briatte, Moritz\nMarbach, Edwin Thoen, Amos Elberg, and Jason Crowley. 2021. GGally: Extension to ggplot2. https://CRAN.R-project.org/package=GGally.\n\n\nTierney, Nicholas, Di Cook, Miles McBain, and Colin Fay. 2021. naniar: Data Structures, Summaries, and Visualisations\nfor Missing Data. https://CRAN.R-project.org/package=naniar.\n\n\nTreischl, Edgar J. 2023. Practice R: An\nInteractive Textbook. De Gruyter Oldenbourg.\n\n\nWaring, Elin, Michael Quinn, Amelia McNamara, Eduardo Arino de la Rubia,\nHao Zhu, and Shannon Ellis. 2022. skimr:\nCompact and Flexible Summaries of Data. https://CRAN.R-project.org/package=skimr.\n\n\nWickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2022.\ndplyr: A Grammar of Data\nManipulation. https://CRAN.R-project.org/package=dplyr."
  }
]